# Spoke AKS Infrastructure Deployment Pipeline
# Deploys spoke Terraform code per .github/instructions/spoke-deploy.instructions.md
#
# Prerequisites (one-time manual setup):
#   1. Run scripts/setup-ado-pipeline.sh to create:
#      - ARM service connection with Workload Identity Federation
#      - Platform Key Vault with SSH keys
#   2. Set pipeline variable PLATFORM_KV_ID to the platform Key Vault resource ID
#      - Go to Pipelines → spoke-deploy → Edit → Variables → New variable
#      - Name: PLATFORM_KV_ID, Value: /subscriptions/.../resourceGroups/.../providers/Microsoft.KeyVault/vaults/...
#
# CRITICAL: Hub infrastructure must be deployed BEFORE spoke deployment.
# This pipeline REQUIRES self-hosted agents — private AKS API server and
# private state SA are only accessible from the CI/CD VNet.

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - infra/terraform/spoke/**

pool:
  name: 'aci-cicd-pool'

variables:
  - name: TF_WORKING_DIR
    value: 'infra/terraform/spoke'
  - name: ENVIRONMENT
    value: 'prod'
  - name: ARM_USE_OIDC
    value: 'true'
  - name: TF_VAR_FILE
    value: 'prod.tfvars'
  - name: BACKEND_CONFIG
    value: 'backend-prod.tfbackend'

stages:
  - stage: Validate
    displayName: 'Terraform Validate'
    jobs:
      - job: Validate
        displayName: 'Format & Validate'
        steps:
          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '1.14.5'

          - task: AzureCLI@2
            displayName: 'Terraform Init & Validate'
            inputs:
              azureSubscription: 'azure-spoke-prod'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                # Export OIDC credentials for Terraform
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_OIDC_TOKEN=$idToken
                export ARM_USE_OIDC=true
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                cd $(TF_WORKING_DIR)

                terraform init -backend-config=$(BACKEND_CONFIG)
                terraform fmt -check -recursive
                terraform validate

  - stage: Plan
    displayName: 'Terraform Plan'
    dependsOn: Validate
    jobs:
      - job: Plan
        displayName: 'Generate Plan'
        steps:
          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '1.14.5'

          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: 'azure-spoke-prod'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_OIDC_TOKEN=$idToken
                export ARM_USE_OIDC=true
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                cd $(TF_WORKING_DIR)

                terraform init -backend-config=$(BACKEND_CONFIG)
                terraform plan \
                  -var-file="$(TF_VAR_FILE)" \
                  -var="platform_key_vault_id=$(PLATFORM_KV_ID)" \
                  -out=tfplan \
                  -input=false

          - publish: $(TF_WORKING_DIR)/tfplan
            artifact: tfplan
            displayName: 'Publish Plan Artifact'

  - stage: Apply
    displayName: 'Terraform Apply'
    dependsOn: Plan
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Apply
        displayName: 'Apply Infrastructure'
        steps:
          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '1.14.5'

          - download: current
            artifact: tfplan
            displayName: 'Download Plan Artifact'

          - task: AzureCLI@2
            displayName: 'Terraform Apply'
            inputs:
              azureSubscription: 'azure-spoke-prod'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_OIDC_TOKEN=$idToken
                export ARM_USE_OIDC=true
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                cd $(TF_WORKING_DIR)

                terraform init -backend-config=$(BACKEND_CONFIG)
                terraform apply -input=false $(Pipeline.Workspace)/tfplan/tfplan

          - task: AzureCLI@2
            displayName: 'Export Terraform Outputs'
            name: tfOutputs
            inputs:
              azureSubscription: 'azure-spoke-prod'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_OIDC_TOKEN=$idToken
                export ARM_USE_OIDC=true
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

                cd $(TF_WORKING_DIR)

                terraform init -backend-config=$(BACKEND_CONFIG)

                echo "=== Spoke Infrastructure Outputs ==="
                terraform output -json

                # Export outputs as pipeline variables for PostDeploy stage
                AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
                AKS_RG_NAME=$(terraform output -raw resource_group_name)
                WEB_APP_ROUTING=$(terraform output -raw web_app_routing_enabled)

                echo "##vso[task.setvariable variable=aksClusterName;isOutput=true]${AKS_CLUSTER_NAME}"
                echo "##vso[task.setvariable variable=aksResourceGroup;isOutput=true]${AKS_RG_NAME}"
                echo "##vso[task.setvariable variable=webAppRoutingEnabled;isOutput=true]${WEB_APP_ROUTING}"

  - stage: PostDeploy
    displayName: 'Apply Kubernetes Manifests'
    dependsOn: Apply
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      aksClusterName: $[ stageDependencies.Apply.Apply.outputs['tfOutputs.aksClusterName'] ]
      aksResourceGroup: $[ stageDependencies.Apply.Apply.outputs['tfOutputs.aksResourceGroup'] ]
      webAppRoutingEnabled: $[ stageDependencies.Apply.Apply.outputs['tfOutputs.webAppRoutingEnabled'] ]
    jobs:
      - job: NginxDeploy
        displayName: 'Deploy NGINX Internal Controller'
        condition: eq(variables['webAppRoutingEnabled'], 'true')
        steps:
          - task: AzureCLI@2
            displayName: 'Apply NGINX Internal Controller Manifest'
            inputs:
              azureSubscription: 'azure-spoke-prod'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                set -euo pipefail

                echo "=== Getting AKS Credentials ==="
                az aks get-credentials \
                  --name "$(aksClusterName)" \
                  --resource-group "$(aksResourceGroup)" \
                  --overwrite-existing

                echo "=== Applying NGINX Internal Controller Manifest ==="
                kubectl apply -f $(TF_WORKING_DIR)/manifests/nginx-internal-controller.yaml

                echo "=== Waiting for NginxIngressController to be ready ==="
                # Wait up to 3 minutes for the controller to provision
                for i in $(seq 1 18); do
                  STATUS=$(kubectl get nginxingresscontroller nginx-internal -o jsonpath='{.status.controllerReadyReplicas}' 2>/dev/null || echo "0")
                  if [ "$STATUS" != "0" ] && [ -n "$STATUS" ]; then
                    echo "NGINX controller ready with $STATUS replicas"
                    break
                  fi
                  echo "Waiting for NGINX controller... (attempt $i/18)"
                  sleep 10
                done

                echo ""
                echo "=== NGINX Ingress Controller Status ==="
                kubectl get nginxingresscontroller nginx-internal -o wide 2>/dev/null || echo "Controller not yet available"

                echo ""
                echo "=== App Routing System Services ==="
                kubectl get svc -n app-routing-system 2>/dev/null || echo "No services found"
